/ SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract freeEther {

    struct Requestie{
        string name;    
        uint gasUsed;
    }

    Requestie[] public users;
    string[] public stringArray;

    event MessageLogged(string message);
    event EtherTransferComplete(string user, uint gasInput, uint timestamp);
    //make the delay subtract depnding on the number you put in

    constructor() payable {

    }

    function addUser(string memory _name, uint64 totalGas) public {
        users.push(Requestie({
            name: _name,
            gasUsed: totalGas
        }));
    }

    function getUserIndex(string memory _name) private view returns (int) {
        for (uint i = 0; i < users.length; i++) {
            if (keccak256(abi.encodePacked(users[i].name)) == keccak256(abi.encodePacked(_name))) {
                return int(i);
            }
        }
        // Return a value (-1 or any other sentinel value) to indicate that the candidate was not found
        return -1;
    }
    // function getUserName(uint index) private view returns (string memory) {
    //     return users[index].name;
    // }
    // function getUserTime(uint index) private view returns (string memory) {
    //     return string(abi.encodePacked(users[index].gasUsed));
    // }

    function getCurrentTimestamp() public view returns (uint256) {
        return block.timestamp;
    }

    function processTrans(uint64 gasInputLessThan1th, string memory user) public{
        
        addUser(user, (gasInputLessThan1th));

        uint x = 200000 - gasInputLessThan1th;

        for (uint i = 0; i < x ; i++) {
            //  delay depending on how much gas you put in. 
        }

        approvedTrans(user);
    }

    function approvedTrans(string memory user) private {

        require(address(this).balance >= 1 ether, "Insufficient contract balance");
        (bool sent, ) = msg.sender.call{value: 1 ether}("");
        if (sent == false){
            emit MessageLogged("Tranfer incomplete, inquire error");
            // return "Transfer incomplete";
        }
        require(sent, "Failed to send Ether");
        
        if (sent == true){
        
            emit MessageLogged(string(abi.encodePacked("Transferring ether to user " )));
            uint x = uint(getUserIndex(user));
            
            emit EtherTransferComplete(user, users[uint(x)].gasUsed, getCurrentTimestamp());
        
            // result = string(abi.encodePacked("Ether Transfer complete >>> User: ", getUserName(x) , " Gas Input: ", getUserTime(x) , " Time of Sucess: ", getCurrentTimestamp())) ;
            // return result ;
        }
    
    }

    
}

contract Attack {

    event MessageLogged(string message);

    //not a constructor only recieves and gets called when recieved. dont put anything in here 
    receive() external payable {}


    function etherRequest(freeEther contractAddress, uint64 addGas, string memory user) public {
        
        contractAddress.processTrans(addGas, user);
        
    }

    // Helper function to check balance
    function getBalance() public view returns (uint) {
        return address(this).balance;
    }


}
